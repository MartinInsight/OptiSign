// Chart instances global variables
let KCCIChart;
let SCFIChart;
let WCIChart;
let IACIChart;
let blankSailingChart;
let FBXChart;
let XSIChart;
let MBCIChart; // New chart for MBCI
let exchangeRateChart; // Chart for exchange rates

// Path to the JSON data file generated by the Python script
const DATA_JSON_URL = 'data/crawling_data.json';

// --- Frontend Section Mappings (linking Python section keys to HTML element IDs) ---
// This object maps the section keys used in the Python script's JSON output
// to the corresponding HTML canvas and table container IDs in the dashboard.
const SECTION_MAPPINGS_FRONTEND = {
    "KCCI": {
        chartId: "KCCIChart",
        tableId: "KCCITableContainer"
    },
    "SCFI": {
        chartId: "SCFIChart",
        tableId: "SCFITableContainer"
    },
    "WCI": {
        chartId: "WCIChart",
        tableId: "WCITableContainer"
    },
    "IACI": {
        chartId: "IACIChart",
        tableId: "IACITableContainer"
    },
    "BLANK_SAILING": {
        chartId: "blankSailingChart", // Note: HTML uses 'blankSailingChart'
        tableId: "BLANK_SAILINGTableContainer"
    },
    "FBX": {
        chartId: "FBXChart",
        tableId: "FBXTableContainer"
    },
    "XSI": {
        chartId: "XSIChart",
        tableId: "XSITableContainer"
    },
    "MBCI": {
        chartId: "MBCIChart",
        tableId: "MBCITableContainer"
    }
};

document.addEventListener('DOMContentLoaded', () => {
    // --- Chart Initialization Function ---
    // This function creates or updates a Chart.js instance.
    // Added isAggregated parameter to control X-axis behavior
    // Changed datasets to expect {x, y} objects for time series
    const setupChart = (chartId, type, datasets, additionalOptions = {}, isAggregated = false) => {
        const ctx = document.getElementById(chartId);
        if (ctx) {
            // Destroy existing chart instance if it exists to prevent conflicts
            if (Chart.getChart(chartId)) {
                Chart.getChart(chartId).destroy();
            }

            const defaultOptions = {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        display: true,
                        title: {
                            display: true,
                            text: 'Date' // Default X-axis title
                        },
                        type: 'time',
                        time: {
                            unit: isAggregated ? 'month' : 'day', // Use 'month' for aggregated, 'day' for granular
                            displayFormats: {
                                // Updated to 'MMM 'yy' for month unit as per requirements
                                month: 'MMM \'yy',
                                // Changed 'MM-dd' to 'MM/dd' to potentially resolve RangeError
                                day: 'M/dd'
                            },
                            // Tooltip format updated to 'M/d/yyyy' as per requirements
                            tooltipFormat: 'M/d/yyyy'
                        },
                        ticks: {
                            source: 'auto',
                            autoSkipPadding: 10 // Add padding to avoid overlapping labels
                        },
                        grid: {
                            display: false // Remove vertical grid lines (X-axis grid)
                        }
                    },
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Value' // Default Y-axis title
                        },
                        ticks: {
                            maxTicksLimit: 5, // Limit to 5 ticks
                            color: '#666'
                        },
                        grid: {
                            display: true, // Display Y-axis grid lines
                            drawOnChartArea: true, // Draw on chart area
                            drawTicks: false, // Do not draw ticks on grid lines
                            color: 'rgba(200, 200, 200, 0.2)', // Light grey color
                            z: -1 // Draw behind the graph
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: true,
                        position: 'right' // Legend position is 'right'
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false
                    }
                },
                elements: {
                    point: {
                        radius: 0 // Remove points on line charts
                    }
                }
            };

            // Apply maxTicksLimit only if isAggregated is true
            if (isAggregated) {
                defaultOptions.scales.x.ticks.maxTicksLimit = 12;
            } else {
                delete defaultOptions.scales.x.ticks.maxTicksLimit;
            }

            // Merge default options with any additional options provided
            const options = { ...defaultOptions, ...additionalOptions };
            if (options.scales && additionalOptions.scales) {
                options.scales = { ...defaultOptions.scales, ...additionalOptions.scales };
                if (options.scales.x && additionalOptions.scales.x) {
                    options.scales.x = { ...defaultOptions.scales.x, ...additionalOptions.scales.x };
                    if (isAggregated) {
                        options.scales.x.ticks.maxTicksLimit = 12;
                    } else {
                        delete options.scales.x.ticks.maxTicksLimit;
                    }
                }
                if (options.scales.y && additionalOptions.scales.y) {
                    options.scales.y = { ...defaultOptions.scales.y, ...additionalOptions.scales.y };
                }
            }

            // For bar charts, Chart.js typically expects `labels` in `data` object, not `x` in dataset.data
            // If type is 'bar' and labels are provided in additionalOptions, use them.
            let chartData = { datasets: datasets };
            if (type === 'bar' && additionalOptions.labels) {
                chartData = { labels: additionalOptions.labels, datasets: datasets };
                delete additionalOptions.labels; // Remove from options to avoid conflict
            }


            return new Chart(ctx, {
                type: type,
                data: chartData,
                options: options
            });
        }
        return null;
    };

    // --- Color Palette Helper ---
    const colors = [
        'rgba(0, 101, 126, 0.8)', // Teal
        'rgba(0, 58, 82, 0.8)',  // Navy
        'rgba(40, 167, 69, 0.8)', // Green
        'rgba(253, 126, 20, 0.8)', // Orange
        'rgba(111, 66, 193, 0.8)', // Purple
        'rgba(220, 53, 69, 0.8)', // Red
        'rgba(23, 162, 184, 0.8)', // Info Blue
        'rgba(108, 117, 125, 0.8)' // Gray
    ];

    const borderColors = [
        '#00657e', // Darker Teal
        '#003A52', // Darker Navy
        '#218838', // Darker Green
        '#e68a00', // Darker Orange
        '#5a32b2', // Darker Purple
        '#c82333', // Darker Red
        '#138496', // Darker Info Blue
        '#6c757d' // Darker Gray
    ];

    let colorIndex = 0;
    const getNextColor = () => {
        const color = colors[colorIndex % colors.length];
        colorIndex++;
        return color;
    };
    const getNextBorderColor = () => {
        const color = borderColors[colorIndex % borderColors.length]; // Use same index for border color
        return color;
    };

    // --- Helper function to aggregate data by month ---
    // This function will now only be used for the Blank Sailing bar chart
    const aggregateDataByMonth = (data, numMonths = 12) => {
        if (data.length === 0) return { aggregatedData: [], monthlyLabels: [] };

        // Sort data by date in ascending order (important for time series)
        data.sort((a, b) => new Date(a.date) - new Date(b.date));

        const monthlyDataMap = new Map(); // Map to store data grouped by 'YYYY-MM'

        // Determine the range of months to consider based on the latest date
        const latestDate = new Date(data[data.length - 1].date);
        const startDate = new Date(latestDate);
        startDate.setMonth(latestDate.getMonth() - (numMonths - 1)); // Go back numMonths-1 months to include current month

        // Generate all month keys for the last numMonths, ensuring no gaps
        const allMonthKeys = [];
        let currentMonth = new Date(startDate.getFullYear(), startDate.getMonth(), 1); // Start from the beginning of the start month
        while (currentMonth <= latestDate) {
            allMonthKeys.push(`${currentMonth.getFullYear()}-${(currentMonth.getMonth() + 1).toString().padStart(2, '0')}`);
            currentMonth.setMonth(currentMonth.getMonth() + 1);
        }

        // Populate monthlyDataMap with sums and counts from raw data
        data.forEach(item => {
            const date = new Date(item.date);
            const yearMonth = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}`;

            if (!monthlyDataMap.has(yearMonth)) {
                monthlyDataMap.set(yearMonth, {});
            }
            const monthEntry = monthlyDataMap.get(yearMonth);

            for (const key in item) {
                if (key !== 'date' && item[key] !== null && !isNaN(item[key])) {
                    if (!monthEntry[key]) {
                        monthEntry[key] = { sum: 0, count: 0 };
                    }
                    monthEntry[key].sum += item[key];
                    monthEntry[key].count++;
                }
            }
        });

        const aggregatedData = [];
        const monthlyLabels = [];

        // Aggregate data for each month key in the desired range
        // Ensure all possible data keys are considered, even if a month has no data for a specific key
        const allDataKeys = new Set();
        if (data.length > 0) {
            Object.keys(data[0]).forEach(key => {
                if (key !== 'date') allDataKeys.add(key);
            });
        }

        allMonthKeys.forEach(yearMonth => {
            const monthEntry = monthlyDataMap.get(yearMonth);
            const newEntry = { date: yearMonth + '-01' }; // Use first day of the month for consistent date

            allDataKeys.forEach(key => {
                newEntry[key] = monthEntry && monthEntry[key] && monthEntry[key].count > 0
                                ? monthEntry[key].sum / monthEntry[key].count
                                : null; // Use null for missing data
            });
            
            aggregatedData.push(newEntry);
            monthlyLabels.push(yearMonth + '-01'); // For Chart.js labels
        });

        return { aggregatedData: aggregatedData, monthlyLabels: monthlyLabels };
    };

    // --- Generic Slider Logic ---
    const setupSlider = (slidesSelector, intervalTime) => {
        const slides = document.querySelectorAll(slidesSelector);
        let currentSlide = 0;

        const showSlide = (index) => {
            slides.forEach((slide, i) => {
                if (i === index) {
                    slide.classList.add('active');
                } else {
                    slide.classList.remove('active');
                }
            });
        };

        const nextSlide = () => {
            currentSlide = (currentSlide + 1) % slides.length;
            showSlide(currentSlide);
        };

        if (slides.length > 0) {
            showSlide(currentSlide);
            if (slides.length > 1) {
                setInterval(nextSlide, intervalTime);
            }
        }
    };

    // --- World Clock Logic ---
    const cityTimezones = {
        'la': 'America/Los_Angeles',
        'ny': 'America/New_York',
        'paris': 'Europe/Paris',
        'shanghai': 'Asia/Shanghai',
        'seoul': 'Asia/Seoul',
        'sydney': 'Australia/Sydney'
    };

    function updateWorldClocks() {
        const now = new Date();
        for (const cityKey in cityTimezones) {
            const timezone = cityTimezones[cityKey];
            const options = {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false,
                timeZone: timezone
            };
            const timeString = new Intl.DateTimeFormat('en-US', options).format(now);
            const elementId = `time-${cityKey}`;
            const timeElement = document.getElementById(elementId);
            if (timeElement) {
                timeElement.textContent = timeString;
            }
        }
    }

    // --- Table Rendering Function ---
    const renderTable = (containerId, headers, rows) => {
        const container = document.getElementById(containerId);
        if (!container) {
            console.warn(`Table container with ID ${containerId} not found.`);
            return;
        }

        // Clear previous content
        container.innerHTML = '';

        if (!headers || headers.length === 0 || !rows || rows.length === 0) {
            container.innerHTML = '<p class="text-gray-600 text-center">No data available for this table.</p>';
            return;
        }

        const table = document.createElement('table');
        table.classList.add('chart-table'); // Use the existing chart-table class for styling

        // Create table header
        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        headers.forEach(headerText => {
            const th = document.createElement('th');
            th.textContent = headerText; // Use the header text directly from Python (already formatted with dates)
            headerRow.appendChild(th);
        });
        thead.appendChild(headerRow);
        table.appendChild(thead);

        // Create table body
        const tbody = document.createElement('tbody');
        rows.forEach(rowData => {
            const tr = document.createElement('tr');
            // Iterate through the headers to ensure correct cell order and content
            headers.forEach(header => {
                const td = document.createElement('td');
                let content = '';
                let colorClass = '';

                if (header.includes('Weekly Change')) {
                    const weeklyChange = rowData.weekly_change;
                    if (weeklyChange) {
                        content = `${weeklyChange.value} (${weeklyChange.percentage})`;
                        colorClass = weeklyChange.color_class;
                    }
                } else if (header.includes('Current Index')) {
                    content = rowData.current_index !== null ? rowData.current_index.toLocaleString() : '-';
                } else if (header.includes('Previous Index')) {
                    content = rowData.previous_index !== null ? rowData.previous_index.toLocaleString() : '-';
                } else { // This will cover the "항로" column
                    content = rowData.route || '-';
                }
                
                td.textContent = content;
                if (colorClass) {
                    td.classList.add(colorClass);
                }
                tr.appendChild(td);
            });
            tbody.appendChild(tr);
        });
        table.appendChild(tbody);
        container.appendChild(table);
    };

    // --- Mapping between table route names and chart data keys ---
    // The keys here MUST match the 'route' values coming from the Python-generated table_data.rows
    // which are the Korean names defined in Python's TABLE_DATA_CELL_MAPPINGS['section_key']['route_names'].
    const routeToDataKeyMap = {
        KCCI: {
            "종합지수": "Composite_Index",
            "미주서안": "US_West_Coast",
            "미주동안": "US_East_Coast",
            "유럽": "Europe",
            "지중해": "Mediterranean",
            "중동": "Middle_East",
            "호주": "Australia",
            "남미동안": "South_America_East_Coast",
            "남미서안": "South_America_West_Coast",
            "남아프리카": "South_Africa",
            "서아프리카": "West_Africa",
            "중국": "China",
            "일본": "Japan",
            "동남아시아": "Southeast_Asia"
        },
        SCFI: {
            "Comprehensive Index": "Composite_Index_1",
            "Europe (Base port)": "North_Europe",
            "Mediterranean (Base port)": "Mediterranean_1",
            "USWC (Base port)": "US_West_Coast_1",
            "USEC (Base port)": "US_East_Coast_1",
            "Persian Gulf and Red Sea (Dubai)": "Middle_East_1",
            "Australia/New Zealand (Melbourne)": "Australia_New_Zealand_SCFI",
            "East/West Africa (Lagos)": "East_West_Africa_SCFI",
            "South Africa (Durban)": "South_Africa_SCFI",
            "West Japan (Base port)": "Japan_West_Coast_SCFI",
            "East Japan (Base port)": "Japan_East_Coast_SCFI",
            "Southeast Asia (Singapore)": "Southeast_Asia_1",
            "Korea (Pusan)": "Korea_SCFI",
            "Central/South America West Coast(Manzanillo)": "South_America_SCFI"
        },
        WCI: {
            "Composite Index": "Composite_Index_2",
            "Shanghai-Rotterdam": "Shanghai_Rotterdam_WCI",
            "Rotterdam-Shanghai": "Rotterdam_Shanghai_WCI",
            "Shanghai-Genoa": "Shanghai_Genoa_WCI",
            "Shanghai-LosAngeles": "Shanghai_Los_Angeles_WCI",
            "LosAngeles-Shanghai": "Los_Angeles_Shanghai_WCI",
            "Shanghai-NewYork": "Shanghai_New_York_WCI",
            "NewYork-Rotterdam": "New_York_Rotterdam_WCI",
            "Rotterdam-NewYork": "Rotterdam_New_York_WCI"
        },
        IACI: {
            "US$/40ft": "Composite_Index_3"
        },
        BLANK_SAILING: {
            "Gemini Cooperation": "Gemini_Cooperation_Blank_Sailing",
            "MSC": "MSC_Alliance_Blank_Sailing",
            "OCEAN Alliance": "OCEAN_Alliance_Blank_Sailing",
            "Premier Alliance": "Premier_Alliance_Blank_Sailing",
            "Others/Independent": "Others_Independent_Blank_Sailing",
            "Total": "Total_Blank_Sailings"
        },
        FBX: {
            "Global Container Freight Index": "Composite_Index_4",
            "China/East Asia - North America West Coast": "China_EA_US_West_Coast_FBX",
            "North America West Coast - China/East Asia": "US_West_Coast_China_EA_FBX",
            "China/East Asia - North America East Coast": "China_EA_US_East_Coast_FBX",
            "North America East Coast - China/East Asia": "US_East_Coast_China_EA_FBX",
            "China/East Asia - North Europe": "China_EA_North_Europe_FBX",
            "North Europe - China/East Asia": "North_Europe_China_EA_FBX",
            "China/East Asia - Mediterranean": "China_EA_Mediterranean_FBX",
            "Mediterranean - China/East Asia": "Mediterranean_China_EA_FBX",
            "North America East Coast - North Europe": "US_East_Coast_North_Europe_FBX",
            "North Europe - North America East Coast": "North_Europe_US_East_Coast_FBX",
            "Europe - South America East Coast": "Europe_South_America_East_Coast_FBX",
            "Europe - South America West Coast": "Europe_South_America_West_Coast_FBX"
        },
        XSI: {
            "Far East - N. Europe": "XSI_East_Asia_North_Europe",
            "N. Europe - Far East": "XSI_North_Europe_East_Asia",
            "Far East - USWC": "XSI_East_Asia_US_West_Coast",
            "USWC - Far East": "XSI_US_West_Coast_East_Asia",
            "Far East - SAEC": "XSI_East_Asia_South_America_East_Coast",
            "N. Europe - USEC": "XSI_North_Europe_US_East_Coast",
            "USEC - N. Europe": "XSI_US_East_Coast_North_Europe",
            "N. Europe - SAEC": "XSI_North_Europe_South_America_East_Coast"
        },
        MBCI: {
            "Index(종합지수)": "MBCI_MBCI_Value",
            "$/day(정기용선, Time charter)": null
        }
    };

    // --- Helper function to create datasets based on table rows and chart data ---
    const createDatasetsFromTableRows = (indexType, chartData, tableRows) => {
        const datasets = [];
        const mapping = routeToDataKeyMap[indexType];
        if (!mapping) {
            console.warn(`No data key mapping found for index type: ${indexType}`);
            return datasets;
        }

        tableRows.forEach(row => {
            const routeName = row.route;
            const dataKey = mapping[routeName];
            
            console.log(`DEBUG: ${indexType} - Processing route: '${routeName}', mapped to dataKey: '${dataKey}'`);

            // Only create a dataset if a corresponding data key exists and current_index is not empty
            // This handles cases like MBCI's second row which has no chart data
            if (dataKey && row.current_index !== null && row.current_index !== undefined && row.current_index !== "") {
                const mappedData = chartData.map(item => {
                    const xVal = item.date; // This should be a string like 'YYYY-MM-DD'
                    const yVal = item[dataKey];
                    return { x: xVal, y: yVal };
                });

                // Filter out null/undefined y values from the data points for the chart
                const filteredMappedData = mappedData.filter(dp => dp.y !== null && dp.y !== undefined);

                console.log(`DEBUG: ${indexType} - route: '${routeName}', dataKey: '${dataKey}', filteredMappedData length: ${filteredMappedData.length}`);
                if (filteredMappedData.length > 0) {
                    datasets.push({
                        label: routeName, // Use the route name directly from the table for the legend
                        data: filteredMappedData,
                        backgroundColor: getNextColor(),
                        borderColor: getNextBorderColor(),
                        borderWidth: (routeName.includes('Composite Index') || routeName.includes('종합지수') || routeName.includes('Global Container Freight Index') || routeName.includes('US$/40ft') || routeName.includes('Index(종합지수)')) ? 2 : 1, // Make composite index lines thicker
                        fill: false
                    });
                } else {
                    console.warn(`WARNING: No valid data points found for ${indexType} - route: '${routeName}' (dataKey: '${dataKey}'). Skipping dataset.`);
                }
            } else if (dataKey === null) {
                console.log(`INFO: Skipping chart dataset for route '${routeName}' in ${indexType} as it's explicitly mapped to null (no chart data expected).`);
            } else {
                console.warn(`WARNING: Skipping chart dataset for route '${routeName}' in ${indexType} due to missing dataKey or empty current_index.`);
            }
        });
        return datasets;
    };


    // --- Data Loading and Dashboard Update Function ---
    async function loadAndDisplayData() {
        let allDashboardData = {}; // Will hold chart_data, weather_data, exchange_rates, table_data
        try {
            const response = await fetch(DATA_JSON_URL);
            if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
            }
            allDashboardData = await response.json();
            console.log("Loaded all dashboard data:", allDashboardData);

            const chartDataBySection = allDashboardData.chart_data || {};
            const weatherData = allDashboardData.weather_data || {};
            const exchangeRatesData = allDashboardData.exchange_rates || [];
            const tableDataBySection = allDashboardData.table_data || {}; // New: Get table data

            if (Object.keys(chartDataBySection).length === 0) {
                console.warn("No chart data sections found in the JSON file.");
                // document.querySelector('.chart-slider-container').innerHTML = '<p class="placeholder-text">No chart data available.</p>';
                // Removed this as it might hide other parts of the dashboard
                return;
            }

            // --- Update Weather Info ---
            const currentWeatherData = weatherData.current || {};
            const forecastWeatherData = weatherData.forecast || [];

            // Corrected IDs for weather elements
            document.getElementById('temperature-current').textContent = currentWeatherData.LA_Temperature !== null ? `${currentWeatherData.LA_Temperature}°F` : '--°F';
            document.getElementById('status-current').textContent = currentWeatherData.LA_WeatherStatus || 'Loading...';
            // Simple icon mapping (you might want a more robust one)
            const weatherIconElement = document.getElementById('weather-icon-current');
            if (currentWeatherData.LA_WeatherStatus) {
                if (currentWeatherData.LA_WeatherStatus.includes('맑음')) {
                    weatherIconElement.src = 'https://placehold.co/80x80/00657e/ffffff?text=SUN';
                } else if (currentWeatherData.LA_WeatherStatus.includes('흐림') || currentWeatherData.LA_WeatherStatus.includes('구름')) {
                    weatherIconElement.src = 'https://placehold.co/80x80/003A52/ffffff?text=CLOUD';
                } else if (currentWeatherData.LA_WeatherStatus.includes('비')) {
                    weatherIconElement.src = 'https://placehold.co/80x80/28A745/ffffff?text=RAIN';
                } else if (currentWeatherData.LA_WeatherStatus.includes('눈')) {
                    weatherIconElement.src = 'https://placehold.co/80x80/138496/ffffff?text=SNOW';
                } else {
                    weatherIconElement.src = 'https://placehold.co/80x80/cccccc/ffffff?text=Icon'; // Default unknown
                }
            } else {
                weatherIconElement.src = 'https://placehold.co/80x80/cccccc/ffffff?text=Icon';
            }

            document.getElementById('humidity-current').textContent = currentWeatherData.LA_Humidity !== null ? `${currentWeatherData.LA_Humidity}%` : '--%';
            document.getElementById('wind-speed-current').textContent = currentWeatherData.LA_WindSpeed !== null ? `${currentWeatherData.LA_WindSpeed} mph` : '-- mph';
            document.getElementById('pressure-current').textContent = currentWeatherData.LA_Pressure !== null ? `${currentWeatherData.LA_Pressure} hPa` : '-- hPa';
            document.getElementById('visibility-current').textContent = currentWeatherData.LA_Visibility !== null ? `${currentWeatherData.LA_Visibility} mile` : '-- mile';
            document.getElementById('sunrise-time').textContent = currentWeatherData.LA_Sunrise || '--';
            document.getElementById('sunset-time').textContent = currentWeatherData.LA_Sunset || '--';

            const forecastTableBody = document.getElementById('forecast-body'); // Corrected ID
            forecastTableBody.innerHTML = ''; // Clear existing rows
            if (forecastWeatherData.length > 0) {
                forecastWeatherData.slice(0, 7).forEach(day => { // Display up to 7 days
                    const row = forecastTableBody.insertRow();
                    row.insertCell().textContent = day.date || '--';
                    row.insertCell().textContent = day.min_temp !== null ? `${day.min_temp}°F` : '--';
                    row.insertCell().textContent = day.max_temp !== null ? `${day.max_temp}°F` : '--';
                    row.insertCell().textContent = day.status || '--';
                });
            } else {
                forecastTableBody.innerHTML = '<tr><td colspan="4">No forecast data available.</td></tr>';
            }


            // --- Update Exchange Rate Info ---
            const filteredExchangeRates = exchangeRatesData.slice(Math.max(exchangeRatesData.length - 30, 0)); // Latest 1 month (approx 30 days)
            
            const currentExchangeRate = filteredExchangeRates.length > 0 ? filteredExchangeRates[filteredExchangeRates.length - 1].rate : null;
            document.getElementById('current-exchange-rate-value').textContent = currentExchangeRate !== null ? `${currentExchangeRate.toFixed(2)} KRW` : 'Loading...'; // Corrected ID

            if (exchangeRateChart) exchangeRateChart.destroy();
            
            // Debugging: Log the datasets for Exchange Rate Chart
            const exchangeRateDatasets = [{
                label: 'USD/KRW Exchange Rate',
                data: filteredExchangeRates.map(item => ({ x: item.date, y: item.rate })), // Use x,y for time scale
                backgroundColor: 'rgba(253, 126, 20, 0.5)',
                borderColor: '#e68a00',
                borderWidth: 2,
                fill: false,
                pointRadius: 0 // No points on exchange rate chart
            }];
            console.log("Exchange Rate Chart Datasets (before setup):", exchangeRateDatasets);
            console.log("Exchange Rate Chart Data Sample (first 5 points):", exchangeRateDatasets[0].data.slice(0, 5));


            exchangeRateChart = setupChart(
                'exchangeRateChartCanvas', 'line', // Corrected ID for canvas
                exchangeRateDatasets,
                {
                    scales: {
                        x: {
                            type: 'time', // Changed to time scale
                            time: { 
                                unit: 'day', 
                                displayFormats: { day: 'MM/dd' }, // Changed MM-dd to MM/dd
                                tooltipFormat: 'M/d/yyyy' // Consistent tooltip format
                            },
                            ticks: { autoSkipPadding: 10 } // Removed maxTicksLimit
                        },
                        y: {
                            beginAtZero: false, // Exchange rates might not start at zero
                            grid: { display: true, drawOnChartArea: true, drawTicks: false, color: 'rgba(200, 200, 200, 0.2)', z: -1 }, // Keep Y-axis grid for exchange rate
                            ticks: { maxTicksLimit: 5 }
                        }
                    },
                    plugins: {
                        legend: { display: false } // No legend for this small chart
                    }
                },
                false // Exchange rate chart is granular (not aggregated by month)
            );


            // --- Prepare Chart Data and Initialize Charts ---
            // Iterate through each section defined in SECTION_MAPPINGS_FRONTEND
            for (const sectionKey in SECTION_MAPPINGS_FRONTEND) {
                colorIndex = 0; // Reset color index for each main chart section

                const chartConfig = SECTION_MAPPINGS_FRONTEND[sectionKey];
                const rawChartData = chartDataBySection[sectionKey] || [];
                const tableData = tableDataBySection[sectionKey] || { headers: [], rows: [] };

                console.log(`Processing section: ${sectionKey}`);
                console.log(`Raw Chart Data for ${sectionKey}:`, rawChartData.slice(0, 5)); // Log first 5 entries
                console.log(`Table Data for ${sectionKey}:`, tableData);

                if (chartConfig.chartId && rawChartData.length > 0) {
                    if (sectionKey === "BLANK_SAILING") {
                        // For Blank Sailing, use aggregated data and bar chart
                        const { aggregatedData: aggregatedBSData, monthlyLabels: bsLabels } = aggregateDataByMonth(rawChartData, 12);
                        
                        // Blank Sailing datasets are still manually defined as they are stacked bar charts
                        // The labels here are the route names from the Python script's TABLE_DATA_CELL_MAPPINGS
                        const blankSailingDatasets = [
                            {
                                label: 'Gemini Cooperation',
                                data: aggregatedBSData.map(item => ({ x: item.date, y: item.Gemini_Cooperation_Blank_Sailing })),
                                backgroundColor: 'rgba(0, 101, 126, 0.5)',
                                borderColor: '#00657e',
                                borderWidth: 1,
                                stack: 'blankSailingStack' // Enable stacking
                            },
                            {
                                label: 'MSC',
                                data: aggregatedBSData.map(item => ({ x: item.date, y: item.MSC_Alliance_Blank_Sailing })),
                                backgroundColor: 'rgba(0, 58, 82, 0.5)',
                                borderColor: '#003A52',
                                borderWidth: 1,
                                stack: 'blankSailingStack'
                            },
                            {
                                label: 'OCEAN Alliance',
                                data: aggregatedBSData.map(item => ({ x: item.date, y: item.OCEAN_Alliance_Blank_Sailing })),
                                backgroundColor: 'rgba(40, 167, 69, 0.5)',
                                borderColor: '#218838',
                                borderWidth: 1,
                                stack: 'blankSailingStack'
                            },
                            {
                                label: 'Premier Alliance',
                                data: aggregatedBSData.map(item => ({ x: item.date, y: item.Premier_Alliance_Blank_Sailing })),
                                backgroundColor: 'rgba(253, 126, 20, 0.5)',
                                borderColor: '#e68a00',
                                borderWidth: 1,
                                stack: 'blankSailingStack'
                            },
                            {
                                label: 'Others/Independent',
                                data: aggregatedBSData.map(item => ({ x: item.date, y: item.Others_Independent_Blank_Sailing })),
                                backgroundColor: 'rgba(111, 66, 193, 0.5)',
                                borderColor: '#5a32b2',
                                borderWidth: 1,
                                stack: 'blankSailingStack'
                            },
                            {
                                label: 'Total',
                                data: aggregatedBSData.map(item => ({ x: item.date, y: item.Total_Blank_Sailings })),
                                backgroundColor: 'rgba(220, 53, 69, 0.5)',
                                borderColor: '#c82333',
                                borderWidth: 1,
                                stack: 'blankSailingStack'
                            }
                        ].filter(dataset => dataset.data.some(d => d.y !== null)); // Filter out datasets with no valid data

                        if (blankSailingDatasets.length > 0) {
                            blankSailingChart = setupChart(
                                chartConfig.chartId, 'bar', blankSailingDatasets,
                                {
                                    scales: {
                                        x: { stacked: true },
                                        y: { stacked: true }
                                    }
                                },
                                true // This chart is aggregated
                            );
                        } else {
                            console.warn(`No valid datasets for Blank Sailing chart. Skipping chart creation.`);
                        }
                    } else {
                        // For other charts, use granular data and line chart
                        const datasets = createDatasetsFromTableRows(sectionKey, rawChartData, tableData.rows);
                        if (datasets.length > 0) {
                            window[`${sectionKey}Chart`] = setupChart(chartConfig.chartId, 'line', datasets, {}, false);
                        } else {
                            console.warn(`No valid datasets for ${sectionKey} chart. Skipping chart creation.`);
                        }
                    }
                } else {
                    console.warn(`No raw chart data found for section: ${sectionKey}. Skipping chart creation.`);
                }

                if (chartConfig.tableId && tableData.rows.length > 0) {
                    renderTable(chartConfig.tableId, tableData.headers, tableData.rows);
                } else {
                    console.warn(`No table data found for section: ${sectionKey}. Skipping table rendering.`);
                }
            }

            // Initialize carousels
            // The HTML provided by the user has a different structure for sliders.
            // It uses classes like 'top-info-slide' and 'chart-slide' and a single 'top-info-slider-container'
            // and 'chart-slider-container' without explicit 'carousel-inner' or 'carousel-dots' elements.
            // The `setupSlider` function needs to be adapted to this structure.
            // For now, I will comment out the slider initialization as the HTML structure for it is not fully provided.
            // If the user wants to re-enable sliders, the HTML for them needs to be consistent with the JS.

            // topInfoCarouselInterval = setupSlider('.top-info-slider-container .top-info-slide', 10000);
            // mainChartsCarouselInterval = setupSlider('.chart-slider-container .chart-slide', 10000);

            // Re-enabling the slider setup based on the provided HTML structure
            // The setupSlider function needs to be adapted to manage 'active' class on slides.
            // The HTML provided by the user does not have `carousel-inner` and `carousel-dots` for the sliders,
            // but rather individual slide divs with `top-info-slide` and `chart-slide` classes.
            // The `setupSlider` function needs to be adjusted to work with this.

            const topInfoSlides = document.querySelectorAll('.top-info-slider-container .top-info-slide');
            let currentTopSlide = 0;
            const showTopSlide = (index) => {
                topInfoSlides.forEach((slide, i) => {
                    if (i === index) {
                        slide.classList.add('active');
                    } else {
                        slide.classList.remove('active');
                    }
                });
            };
            if (topInfoSlides.length > 0) {
                showTopSlide(currentTopSlide);
                if (topInfoSlides.length > 1) {
                    topInfoCarouselInterval = setInterval(() => {
                        currentTopSlide = (currentTopSlide + 1) % topInfoSlides.length;
                        showTopSlide(currentTopSlide);
                    }, 10000);
                }
            }


            const mainChartSlides = document.querySelectorAll('.chart-slider-container .chart-slide');
            let currentMainChartSlide = 0;
            const showMainChartSlide = (index) => {
                mainChartSlides.forEach((slide, i) => {
                    if (i === index) {
                        slide.classList.add('active');
                    } else {
                        slide.classList.remove('active');
                    }
                });
            };
            if (mainChartSlides.length > 0) {
                showMainChartSlide(currentMainChartSlide);
                if (mainChartSlides.length > 1) {
                    mainChartsCarouselInterval = setInterval(() => {
                        currentMainChartSlide = (currentMainChartSlide + 1) % mainChartSlides.length;
                        showMainChartSlide(currentMainChartSlide);
                    }, 10000);
                }
            }


        } catch (error) {
            console.error("Failed to load or display dashboard data:", error);
            // Display a user-friendly error message on the dashboard if data loading fails
            document.body.innerHTML = '<div class="flex items-center justify-center min-h-screen bg-red-100 text-red-800 text-lg p-4 rounded-lg m-4">데이터를 불러오는 데 실패했습니다. 잠시 후 다시 시도해 주세요.<br>콘솔에서 더 자세한 오류를 확인할 수 있습니다.</div>';
        }
    }

    // --- World Timezone Setup (using dayjs timezone plugin) ---
    // Make sure dayjs timezone plugin is loaded if needed for Intl.DateTimeFormat
    // For this example, Intl.DateTimeFormat is used directly, which relies on browser's native support.
    // If dayjs.tz() is to be used, ensure the plugin is loaded:
    // dayjs.extend(window.dayjs_plugin_utc);
    // dayjs.extend(window.dayjs_plugin_timezone);
    // dayjs.tz.setDefault('America/Los_Angeles'); // Example default timezone

    // Call the main function when the DOM is fully loaded
    loadAndDisplayData();

    // Clean up intervals on page unload
    window.addEventListener('beforeunload', () => {
        // Clear intervals only if they were successfully set
        if (typeof topInfoCarouselInterval !== 'undefined') {
            clearInterval(topInfoCarouselInterval);
        }
        if (typeof mainChartsCarouselInterval !== 'undefined') {
            clearInterval(mainChartsCarouselInterval);
        }
    });
});
