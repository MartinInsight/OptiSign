// Chart instances global variables
let KCCIChart;
let SCFIChart;
let WCIChart;
let IACIChart;
let blankSailingChart;
let FBXChart;
let XSIChart;
let MBCIChart; // New chart for MBCI
let exchangeRateChart; // Chart for exchange rates

// Path to the JSON data file generated by the Python script
const DATA_JSON_URL = 'data/crawling_data.json';

document.addEventListener('DOMContentLoaded', () => {
    // --- Chart Initialization Function ---
    // This function creates or updates a Chart.js instance.
    // Added isAggregated parameter to control X-axis behavior
    const setupChart = (chartId, type, datasets, labels = [], additionalOptions = {}, isAggregated = true) => {
        const ctx = document.getElementById(chartId);
        if (ctx) {
            // Destroy existing chart instance if it exists to prevent conflicts
            if (Chart.getChart(chartId)) {
                Chart.getChart(chartId).destroy();
            }

            const defaultOptions = {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        display: true,
                        title: {
                            display: true,
                            text: 'Date' // Default X-axis title
                        },
                        type: 'time',
                        time: {
                            unit: 'month', // Always display monthly ticks for all charts
                            displayFormats: {
                                month: 'M/1/yyyy' // Specific format requested: M/1/yyyy
                            },
                            tooltipFormat: 'M/d/yyyy' // Full date in tooltip
                        },
                        ticks: {
                            source: 'auto',
                            autoSkip: false, // Ensure all ticks are shown
                            maxRotation: 45, // Allow rotation for labels to prevent overlap
                            minRotation: 45,
                            autoSkipPadding: 10,
                            // maxTicksLimit is applied only if isAggregated is true, otherwise let Chart.js decide
                            maxTicksLimit: isAggregated ? 12 : undefined // Limit to 12 ticks for aggregated (monthly) data
                        },
                        grid: {
                            display: false // Remove vertical grid lines (X-axis grid)
                        }
                    },
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Value' // Default Y-axis title
                        },
                        ticks: {
                            maxTicksLimit: 5 // Limit Y-axis ticks to 5
                        },
                        grid: {
                            display: true // Add horizontal grid lines (Y-axis grid)
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: true,
                        position: 'right' // Legend position is 'right'
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false
                    }
                },
                elements: {
                    point: {
                        radius: 0 // Remove points on line charts
                    }
                }
            };

            // Merge default options with any additional options provided
            const options = { ...defaultOptions, ...additionalOptions };
            if (options.scales && additionalOptions.scales) {
                options.scales = { ...defaultOptions.scales, ...additionalOptions.scales };
                if (options.scales.x && additionalOptions.scales.x) {
                    options.scales.x = { ...defaultOptions.scales.x, ...additionalOptions.scales.x };
                    // Ensure maxTicksLimit is correctly applied or removed based on isAggregated
                    options.scales.x.ticks.maxTicksLimit = isAggregated ? 12 : undefined;
                }
                if (options.scales.y && additionalOptions.scales.y) {
                    options.scales.y = { ...defaultOptions.scales.y, ...additionalOptions.scales.y };
                }
            }


            return new Chart(ctx, {
                type: type,
                data: {
                    labels: labels,
                    datasets: datasets // Use the provided datasets
                },
                options: options
            });
        }
        return null;
    };

    // --- Color Palette Helper ---
    // Expanded color palette for better visibility and distinction
    const colors = [
        'rgba(255, 99, 132, 0.8)',   // Red
        'rgba(54, 162, 235, 0.8)',   // Blue
        'rgba(255, 206, 86, 0.8)',   // Yellow
        'rgba(75, 192, 192, 0.8)',   // Green-Cyan
        'rgba(153, 102, 255, 0.8)',  // Purple
        'rgba(255, 159, 64, 0.8)',   // Orange
        'rgba(201, 203, 207, 0.8)',  // Grey
        'rgba(0, 128, 128, 0.8)',    // Teal
        'rgba(128, 0, 0, 0.8)',      // Maroon
        'rgba(0, 128, 0, 0.8)',      // Dark Green
        'rgba(0, 0, 128, 0.8)',      // Navy
        'rgba(128, 128, 0, 0.8)',    // Olive
        'rgba(128, 0, 128, 0.8)',    // Violet
        'rgba(0, 255, 0, 0.8)',      // Lime
        'rgba(255, 0, 255, 0.8)',    // Magenta
        'rgba(0, 255, 255, 0.8)',    // Aqua
        'rgba(100, 149, 237, 0.8)',  // Cornflower Blue
        'rgba(218, 112, 214, 0.8)',  // Orchid
        'rgba(255, 140, 0, 0.8)',    // Dark Orange
        'rgba(60, 179, 113, 0.8)',   // Medium Sea Green
        'rgba(178, 34, 34, 0.8)',    // Firebrick
        'rgba(138, 43, 226, 0.8)',   // Blue Violet
        'rgba(255, 215, 0, 0.8)',    // Gold
        'rgba(70, 130, 180, 0.8)'    // Steel Blue
    ];

    const borderColors = [
        '#cc0033', // Darker Red
        '#3366cc', // Darker Blue
        '#cc9900', // Darker Yellow
        '#009999', // Darker Green-Cyan
        '#6633cc', // Darker Purple
        '#cc6600', // Darker Orange
        '#999999', // Darker Grey
        '#006666', // Darker Teal
        '#660000', // Darker Maroon
        '#006600', // Darker Dark Green
        '#000066', // Darker Navy
        '#666600', // Darker Olive
        '#660066', // Darker Violet
        '#00cc00', // Darker Lime
        '#cc00cc', // Darker Magenta
        '#00cccc', // Darker Aqua
        '#4682B4', // Darker Cornflower Blue
        '#9932CC', // Darker Orchid
        '#FF8C00', // Darker Dark Orange
        '#3CB371', // Darker Medium Sea Green
        '#B22222', // Darker Firebrick
        '#8A2BE2', // Darker Blue Violet
        '#DAA520', // Darker Gold
        '#4682B4'  // Darker Steel Blue
    ];

    let colorIndex = 0;
    const getNextColor = () => {
        const color = colors[colorIndex % colors.length];
        colorIndex++;
        return color;
    };
    const getNextBorderColor = () => {
        const color = borderColors[colorIndex % borderColors.length]; // Use same index for border color
        return color;
    };

    // --- Helper function to clean label names ---
    const cleanLabel = (fullLabel) => {
        // Remove prefixes like "KCCI ", "SCFI ", "WCI ", "FBX ", "XSI ", "MBCI "
        return fullLabel.replace(/^(KCCI|SCFI|WCI|FBX|XSI|MBCI)\s/i, '');
    };

    // --- Helper function to aggregate data by month ---
    // This function will now only be used for the Blank Sailing bar chart
    const aggregateDataByMonth = (data, numMonths = 12) => {
        if (!Array.isArray(data) || data.length === 0) return { aggregatedData: [], monthlyLabels: [] };

        // Sort data by date in ascending order (important for time series)
        data.sort((a, b) => new Date(a.date) - new Date(b.date));

        const monthlyDataMap = new Map(); // Map to store data grouped by 'YYYY-MM'

        // Determine the range of months to consider based on the latest date
        const latestDate = new Date(data[data.length - 1].date);
        const startDate = new Date(latestDate);
        startDate.setMonth(latestDate.getMonth() - (numMonths - 1)); // Go back numMonths-1 months to include current month

        // Generate all month keys for the last numMonths, ensuring no gaps
        const allMonthKeys = [];
        let currentMonth = new Date(startDate.getFullYear(), startDate.getMonth(), 1); // Start from the beginning of the start month
        while (currentMonth <= latestDate) {
            allMonthKeys.push(`${currentMonth.getFullYear()}-${(currentMonth.getMonth() + 1).toString().padStart(2, '0')}`);
            currentMonth.setMonth(currentMonth.getMonth() + 1);
        }

        // Populate monthlyDataMap with sums and counts from raw data
        data.forEach(item => {
            const date = new Date(item.date);
            const yearMonth = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}`;

            if (!monthlyDataMap.has(yearMonth)) {
                monthlyDataMap.set(yearMonth, {});
            }
            const monthEntry = monthlyDataMap.get(yearMonth);

            for (const key in item) {
                if (key !== 'date' && item[key] !== null && !isNaN(item[key])) {
                    if (!monthEntry[key]) {
                        monthEntry[key] = { sum: 0, count: 0 };
                    }
                    monthEntry[key].sum += item[key];
                    monthEntry[key].count++;
                }
            }
        });

        const aggregatedData = [];
        const monthlyLabels = [];

        // Aggregate data for each month key in the desired range
        // Ensure all possible data keys are considered, even if a month has no data for a specific key
        const allDataKeys = new Set();
        if (data.length > 0) {
            Object.keys(data[0]).forEach(key => {
                if (key !== 'date') allDataKeys.add(key);
            });
        }

        allMonthKeys.forEach(yearMonth => {
            const monthEntry = monthlyDataMap.get(yearMonth);
            const newEntry = { date: yearMonth + '-01' }; // Use first day of the month for consistent date

            allDataKeys.forEach(key => {
                newEntry[key] = monthEntry && monthEntry[key] && monthEntry[key].count > 0
                                        ? monthEntry[key].sum / monthEntry[key].count
                                        : null; // Use null for missing data
            });
            
            aggregatedData.push(newEntry);
            monthlyLabels.push(yearMonth + '-01'); // For Chart.js labels
        });

        return { aggregatedData: aggregatedData, monthlyLabels: monthlyLabels };
    };

    // --- Generic Slider Logic ---
    const setupSlider = (slidesSelector, intervalTime) => {
        const slides = document.querySelectorAll(slidesSelector);
        let currentSlide = 0;

        const showSlide = (index) => {
            slides.forEach((slide, i) => {
                if (i === index) {
                    slide.classList.add('active');
                } else {
                    slide.classList.remove('active');
                }
            });
        };

        const nextSlide = () => {
            currentSlide = (currentSlide + 1) % slides.length;
            showSlide(currentSlide);
        };

        if (slides.length > 0) {
            showSlide(currentSlide);
            if (slides.length > 1) {
                setInterval(nextSlide, intervalTime);
            }
        }
    };

    // --- World Clock Logic ---
    const cityTimezones = {
        'la': 'America/Los_Angeles',
        'ny': 'America/New_York',
        'paris': 'Europe/Paris',
        'shanghai': 'Asia/Shanghai',
        'seoul': 'Asia/Seoul',
        'sydney': 'Australia/Sydney'
    };

    function updateWorldClocks() {
        const now = new Date();
        for (const cityKey in cityTimezones) {
            const timezone = cityTimezones[cityKey];
            const options = {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false,
                timeZone: timezone
            };
            const timeString = new Intl.DateTimeFormat('en-US', options).format(now);
            const elementId = `time-${cityKey}`;
            const timeElement = document.getElementById(elementId);
            if (timeElement) {
                timeElement.textContent = timeString;
            }
        }
    }

    // --- Data Loading and Dashboard Update Function ---
    async function loadAndDisplayData() {
        let allDashboardData = {}; // Will hold chart_data, weather_data, exchange_rates
        try {
            const response = await fetch(DATA_JSON_URL);
            if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
            }
            allDashboardData = await response.json();
            console.log("Loaded all dashboard data:", allDashboardData);

            // Access specific data sections from the loaded object
            const rawChartDataSections = allDashboardData.chart_data || {}; // This is the object with KCCI, SCFI etc.
            const weatherData = allDashboardData.weather_data || {};
            const exchangeRatesData = allDashboardData.exchange_rates || [];

            // Check if any chart data sections are available
            if (Object.keys(rawChartDataSections).length === 0) {
                console.warn("No chart data sections found in the JSON file.");
                document.querySelector('.chart-slider-container').innerHTML = '<p class="placeholder-text">No chart data available.</p>';
                return;
            }

            // --- Helper to get sorted and optionally filtered data for a specific chart section (last 12 months) ---
            const getProcessedChartData = (dataArray) => {
                if (!Array.isArray(dataArray) || dataArray.length === 0) {
                    return { data: [], dates: [] };
                }
                // Sort data by date in ascending order (important for time series)
                dataArray.sort((a, b) => new Date(a.date) - new Date(b.date));

                const latestDate = new Date(dataArray[dataArray.length - 1].date);
                const twelveMonthsAgo = new Date(latestDate);
                twelveMonthsAgo.setFullYear(latestDate.getFullYear() - 1); // Go back 1 year

                // Filter data to include only the last 12 months (or more if data is sparse)
                const filteredData = dataArray.filter(item => {
                    const itemDate = new Date(item.date);
                    return itemDate >= twelveMonthsAgo; // Include data from 1 year ago to latest date
                });
                
                const dates = filteredData.map(item => item.date);
                return { data: filteredData, dates: dates };
            };

            // Process data for each chart (now filters for last 12 months)
            const { data: KCCIData, dates: KCCIDates } = getProcessedChartData(rawChartDataSections.KCCI);
            const { data: SCFIData, dates: SCFIDates } = getProcessedChartData(rawChartDataSections.SCFI);
            const { data: WCIData, dates: WCIDates } = getProcessedChartData(rawChartDataSections.WCI);
            const { data: IACIData, dates: IACIDates } = getProcessedChartData(rawChartDataSections.IACI);
            const { data: FBXData, dates: FBXDates } = getProcessedChartData(rawChartDataSections.FBX);
            const { data: XSIData, dates: XSIDates } = getProcessedChartData(rawChartDataSections.XSI);
            const { data: MBCIData, dates: MBCIDates } = getProcessedChartData(rawChartDataSections.MBCI);

            // Aggregate blank sailing data separately (it already sorts internally)
            const { aggregatedData: aggregatedBlankSailingData, monthlyLabels: blankSailingChartDates } = aggregateDataByMonth(rawChartDataSections.BLANK_SAILING);
            
            // --- DEBUGGING LOGS ---
            console.log("KCCI Data:", KCCIData);
            console.log("SCFI Data:", SCFIData);
            console.log("WCI Data:", WCIData);
            console.log("IACI Data:", IACIData);
            console.log("FBX Data:", FBXData);
            console.log("XSI Data:", XSIData);
            console.log("MBCI Data:", MBCIData);
            console.log("Aggregated Blank Sailing Data:", aggregatedBlankSailingData);
            console.log("Blank Sailing Chart Dates:", blankSailingChartDates);
            // --- END DEBUGGING LOGS ---

            // --- Update Weather Info ---
            const currentWeatherData = weatherData.current || {};
            const forecastWeatherData = weatherData.forecast || [];

            document.getElementById('temperature-current').textContent = currentWeatherData.LA_Temperature ? `${currentWeatherData.LA_Temperature}°F` : '--°F';
            document.getElementById('status-current').textContent = currentWeatherData.LA_WeatherStatus || 'Loading...';
            // Simple icon mapping (you might want a more robust one)
            const weatherIconUrl = (status) => {
                if (status && status.toLowerCase().includes('clear')) return 'https://placehold.co/80x80/00657e/ffffff?text=SUN'; // Example for clear sky
                if (status && status.toLowerCase().includes('cloud')) return 'https://placehold.co/80x80/003A52/ffffff?text=CLOUD'; // Example for clouds
                if (status && status.toLowerCase().includes('rain')) return 'https://placehold.co/80x80/28A745/ffffff?text=RAIN'; // Example for rain
                return 'https://placehold.co/80x80/cccccc/ffffff?text=Icon'; // Default placeholder
            };
            document.getElementById('weather-icon-current').src = weatherIconUrl(currentWeatherData.LA_WeatherStatus);

            document.getElementById('humidity-current').textContent = currentWeatherData.LA_Humidity ? `${currentWeatherData.LA_Humidity}%` : '--%';
            document.getElementById('wind-speed-current').textContent = currentWeatherData.LA_WindSpeed ? `${currentWeatherData.LA_WindSpeed} mph` : '-- mph';
            document.getElementById('pressure-current').textContent = currentWeatherData.LA_Pressure ? `${currentWeatherData.LA_Pressure} hPa` : '-- hPa';
            document.getElementById('visibility-current').textContent = currentWeatherData.LA_Visibility ? `${currentWeatherData.LA_Visibility} mile` : '-- mile';
            document.getElementById('sunrise-time').textContent = currentWeatherData.LA_Sunrise || '--';
            document.getElementById('sunset-time').textContent = currentWeatherData.LA_Sunset || '--';
            // Removed fine dust update as per user request and HTML removal

            const forecastBody = document.getElementById('forecast-body');
            forecastBody.innerHTML = ''; // Clear existing rows
            if (forecastWeatherData.length > 0) {
                forecastWeatherData.slice(0, 7).forEach(day => { // Display up to 7 days
                    const row = forecastBody.insertRow();
                    row.insertCell().textContent = day.date || '--';
                    row.insertCell().textContent = day.min_temp ? `${day.min_temp}°F` : '--';
                    row.insertCell().textContent = day.max_temp ? `${day.max_temp}°F` : '--';
                    row.insertCell().textContent = day.status || '--';
                });
            } else {
                forecastBody.innerHTML = '<tr><td colspan="4">No forecast data available.</td></tr>';
            }


            // --- Update Exchange Rate Info ---
            const filteredExchangeRates = exchangeRatesData.slice(Math.max(exchangeRatesData.length - 30, 0)); // Latest 1 month (approx 30 days)
            const exchangeRateLabels = filteredExchangeRates.map(item => item.date);
            const exchangeRateValues = filteredExchangeRates.map(item => item.rate);

            const currentExchangeRate = exchangeRateValues[exchangeRateValues.length - 1];
            document.getElementById('current-exchange-rate-value').textContent = currentExchangeRate ? `${currentExchangeRate.toFixed(2)} KRW` : 'Loading...';

            if (exchangeRateChart) exchangeRateChart.destroy();
            exchangeRateChart = setupChart(
                'exchangeRateChartCanvas', 'line',
                [{
                    label: 'USD/KRW Exchange Rate',
                    data: exchangeRateValues,
                    backgroundColor: getNextColor(), // Use dynamic color
                    borderColor: getNextBorderColor(), // Use dynamic border color
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0 // No points on exchange rate chart
                }],
                exchangeRateLabels,
                {
                    scales: {
                        x: {
                            type: 'category', // Use category for exchange rate dates like "MM-DD"
                            time: { unit: 'day', displayFormats: { day: 'MM-DD' } }, // Format for exchange rate dates
                            // Removed maxTicksLimit to allow more ticks for a month view
                        },
                        y: {
                            beginAtZero: false, // Exchange rates might not start at zero
                            grid: { display: true }, // Add grid lines for exchange rate chart
                            ticks: { maxTicksLimit: 5 } // Limit Y-axis ticks to 5
                        }
                    },
                    plugins: {
                        legend: { display: false } // No legend for this small chart
                    }
                },
                false // Exchange rate chart is also granular
            );


            // --- Prepare Chart Data and Initialize Charts ---
            colorIndex = 0; // Reset color index for each chart initialization

            // Chart 1: KCCI - All relevant indices (Granular Data)
            const KCCIDatasets = [
                {
                    label: cleanLabel('KCCI Composite Index'),
                    data: KCCIData.map(item => item.Composite_Index),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 2,
                    fill: false
                },
                {
                    label: cleanLabel('KCCI US West Coast'),
                    data: KCCIData.map(item => item.US_West_Coast),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('KCCI US East Coast'),
                    data: KCCIData.map(item => item.US_East_Coast),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('KCCI Europe'),
                    data: KCCIData.map(item => item.Europe),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('KCCI Mediterranean'),
                    data: KCCIData.map(item => item.Mediterranean),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('KCCI Middle East'),
                    data: KCCIData.map(item => item.Middle_East),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('KCCI Australia'),
                    data: KCCIData.map(item => item.Australia),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('KCCI South America East Coast'),
                    data: KCCIData.map(item => item.South_America_East_Coast),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('KCCI South America West Coast'),
                    data: KCCIData.map(item => item.South_America_West_Coast),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('KCCI South Africa'),
                    data: KCCIData.map(item => item.South_Africa),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('KCCI West Africa'),
                    data: KCCIData.map(item => item.West_Africa),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('KCCI China'),
                    data: KCCIData.map(item => item.China),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('KCCI Japan'),
                    data: KCCIData.map(item => item.Japan),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('KCCI Southeast Asia'),
                    data: KCCIData.map(item => item.Southeast_Asia),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                }
            ];
            KCCIChart = setupChart('KCCIChart', 'line', KCCIDatasets, KCCIDates, {}, false); // Pass false for granular data

            // Chart 2: SCFI - All relevant indices (Granular Data)
            colorIndex = 0; // Reset color index for each chart
            const SCFIDatasets = [
                {
                    label: cleanLabel('SCFI Composite Index'),
                    data: SCFIData.map(item => item.Composite_Index_1),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 2,
                    fill: false
                },
                {
                    label: cleanLabel('SCFI US West Coast'),
                    data: SCFIData.map(item => item.US_West_Coast_1),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('SCFI US East Coast'),
                    data: SCFIData.map(item => item.US_East_Coast_1),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('SCFI North Europe'),
                    data: SCFIData.map(item => item.North_Europe),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('SCFI Mediterranean'),
                    data: SCFIData.map(item => item.Mediterranean_1),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('SCFI Southeast Asia'),
                    data: SCFIData.map(item => item.Southeast_Asia_1),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('SCFI Middle East'),
                    data: SCFIData.map(item => item.Middle_East_1),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('SCFI Australia/New Zealand'),
                    data: SCFIData.map(item => item.Australia_New_Zealand_SCFI),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('SCFI South America'),
                    data: SCFIData.map(item => item.South_America_SCFI),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('SCFI Japan West Coast'),
                    data: SCFIData.map(item => item.Japan_West_Coast_SCFI),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('SCFI Japan East Coast'),
                    data: SCFIData.map(item => item.Japan_East_Coast_SCFI),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('SCFI Korea'),
                    data: SCFIData.map(item => item.Korea_SCFI),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('SCFI East/West Africa'),
                    data: SCFIData.map(item => item.East_West_Africa_SCFI),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('SCFI South Africa'),
                    data: SCFIData.map(item => item.South_Africa_SCFI),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                }
            ];
            SCFIChart = setupChart('SCFIChart', 'line', SCFIDatasets, SCFIDates, {}, false); // Pass false for granular data

            // Chart 3: WCI - All relevant indices (Granular Data)
            colorIndex = 0; // Reset color index for each chart
            const WCIDatasets = [
                {
                    label: cleanLabel('WCI Composite Index'),
                    data: WCIData.map(item => item.Composite_Index_2),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 2,
                    fill: false
                },
                {
                    label: cleanLabel('WCI Shanghai → Rotterdam'),
                    data: WCIData.map(item => item.Shanghai_Rotterdam_WCI),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('WCI Rotterdam → Shanghai'),
                    data: WCIData.map(item => item.Rotterdam_Shanghai_WCI),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('WCI Shanghai → Genoa'),
                    data: WCIData.map(item => item.Shanghai_Genoa_WCI),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('WCI Shanghai → Los Angeles'),
                    data: WCIData.map(item => item.Shanghai_Los_Angeles_WCI),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('WCI Los Angeles → Shanghai'),
                    data: WCIData.map(item => item.Los_Angeles_Shanghai_WCI),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('WCI Shanghai → New York'),
                    data: WCIData.map(item => item.Shanghai_New_York_WCI),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('WCI New York → Rotterdam'),
                    data: WCIData.map(item => item.New_York_Rotterdam_WCI),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('WCI Rotterdam → New York'),
                    data: WCIData.map(item => item.Rotterdam_New_York_WCI),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                }
            ];
            WCIChart = setupChart('WCIChart', 'line', WCIDatasets, WCIDates, {}, false); // Pass false for granular data

            // Chart 4: IACI Composite Index (Granular Data)
            colorIndex = 0; // Reset color index for each chart
            IACIChart = setupChart(
                'IACIChart', 'line',
                [{
                    label: cleanLabel('IACI Composite Index'),
                    data: IACIData.map(item => item.Composite_Index_3),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 2,
                    fill: false
                }],
                IACIDates,
                {},
                false // Pass false for granular data
            );

            // Chart 5: BLANK_SAILING Stacked Bar Chart (Aggregated Data)
            colorIndex = 0; // Reset color index specifically for Blank Sailing to ensure distinct colors
            const blankSailingDatasets = [
                {
                    label: 'Gemini Cooperation',
                    data: aggregatedBlankSailingData.map(item => item.Gemini_Cooperation_Blank_Sailing),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1
                },
                {
                    label: 'MSC Alliance',
                    data: aggregatedBlankSailingData.map(item => item.MSC_Alliance_Blank_Sailing),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1
                },
                {
                    label: 'OCEAN Alliance',
                    data: aggregatedBlankSailingData.map(item => item.OCEAN_Alliance_Blank_Sailing),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1
                },
                {
                    label: 'Premier Alliance',
                    data: aggregatedBlankSailingData.map(item => item.Premier_Alliance_Blank_Sailing),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1
                },
                {
                    label: 'Others/Independent',
                    data: aggregatedBlankSailingData.map(item => item.Others_Independent_Blank_Sailing),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1
                }
            ];

            blankSailingChart = setupChart(
                'blankSailingChart', 'bar', blankSailingDatasets, blankSailingChartDates,
                {
                    scales: {
                        x: { stacked: true },
                        y: { stacked: true, title: { display: true, text: 'Number of Sailings' } }
                    }
                },
                true // Pass true for aggregated data (monthly)
            );

            // Chart 6: FBX - All relevant indices (Granular Data)
            colorIndex = 0; // Reset color index for each chart
            const FBXDatasets = [
                {
                    label: cleanLabel('FBX China/EA → US West Coast'),
                    data: FBXData.map(item => item.China_EA_US_West_Coast_FBX),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 2,
                    fill: false
                },
                {
                    label: cleanLabel('FBX US West Coast → China/EA'),
                    data: FBXData.map(item => item.US_West_Coast_China_EA_FBX),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('FBX China/EA → US East Coast'),
                    data: FBXData.map(item => item.China_EA_US_East_Coast_FBX),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('FBX US East Coast → China/EA'),
                    data: FBXData.map(item => item.US_East_Coast_China_EA_FBX),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('FBX China/EA → North Europe'),
                    data: FBXData.map(item => item.China_EA_North_Europe_FBX),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('FBX North Europe → China/EA'),
                    data: FBXData.map(item => item.North_Europe_China_EA_FBX),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('FBX China/EA → Mediterranean'),
                    data: FBXData.map(item => item.China_EA_Mediterranean_FBX),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('FBX Mediterranean → China/EA'),
                    data: FBXData.map(item => item.Mediterranean_China_EA_FBX),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                }
            ];
            FBXChart = setupChart('FBXChart', 'line', FBXDatasets, FBXDates, {}, false); // Pass false for granular data

            // Chart 7: XSI - All relevant indices (Granular Data)
            colorIndex = 0; // Reset color index for each chart
            const XSIDatasets = [
                {
                    label: cleanLabel('XSI East Asia → North Europe'),
                    data: XSIData.map(item => item.East_Asia_North_Europe),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 2,
                    fill: false
                },
                {
                    label: cleanLabel('XSI North Europe → East Asia'),
                    data: XSIData.map(item => item.North_Europe_East_Asia),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('XSI East Asia → US West Coast'),
                    data: XSIData.map(item => item.East_Asia_US_West_Coast),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('XSI US West Coast → East Asia'),
                    data: XSIData.map(item => item.US_West_Coast_East_Asia),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('XSI East Asia → South America East Coast'),
                    data: XSIData.map(item => item.East_Asia_South_America_East_Coast),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('XSI North Europe → US East Coast'),
                    data: XSIData.map(item => item.North_Europe_US_East_Coast),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('XSI US East Coast → North Europe'),
                    data: XSIData.map(item => item.US_East_Coast_North_Europe),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                },
                {
                    label: cleanLabel('XSI North Europe → South America East Coast'),
                    data: XSIData.map(item => item.North_Europe_South_America_East_Coast),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 1,
                    fill: false
                }
            ];
            XSIChart = setupChart('XSIChart', 'line', XSIDatasets, XSIDates, {}, false); // Pass false for granular data

            // Chart 8: MBCI - All relevant indices (Granular Data)
            colorIndex = 0; // Reset color index for each chart
            const MBCIDatasets = [
                {
                    label: cleanLabel('MBCI Value'),
                    data: MBCIData.map(item => item.MBCI_Value),
                    backgroundColor: getNextColor(),
                    borderColor: getNextBorderColor(),
                    borderWidth: 2,
                    fill: false
                }
            ];
            MBCIChart = setupChart('MBCIChart', 'line', MBCIDatasets, MBCIDates, {}, false); // Pass false for granular data


            // --- Setup and start auto-cycling for both sliders ---
            setupSlider('.top-info-slide', 10000); // 10 seconds for top info slider
            setupSlider('.chart-slide', 10000); // 10 seconds for chart slider

        } catch (error) {
            console.error("Error loading or processing JSON data:", error);
            document.querySelector('.chart-slider-container').innerHTML = '<p class="placeholder-text" style="color: red;">Error loading chart data. Please check the console.</p>';
        }
    }

    // Initial world clock update and 1-second interval update
    updateWorldClocks();
    setInterval(updateWorldClocks, 1000);

    // Update last updated time
    document.getElementById('last-updated').textContent = `Last Updated: ${new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true })}`;

    // Start loading JSON data and displaying the dashboard
    loadAndDisplayData();
});
